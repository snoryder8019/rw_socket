<script>
    document.addEventListener("DOMContentLoaded", function () {
      let spriteImagesCache = {}; // Cache for sprite images
      let spritesMap = {}; // To store sprites by _id
      let gameElements = []; // Store game elements
      let gameElementsCache = {}; // Cache for game elements
      let dealingAnimationActive = true;
      let ctx; // Canvas context will be initialized when the canvas is available

      console.log("DOM loaded, initializing game logic...");

      // Ensure extractGameSettingsData is defined before it is used
      function extractGameSettingsData(cardTableGameDiv) {
        const gameSettings = cardTableGameDiv.getAttribute('data-game-settings');
        if (gameSettings) {
          console.log("Extracting game settings data:", gameSettings);
          return JSON.parse(gameSettings);
        } else {
          console.error('No gameSettingsData found on the cardTableGameDiv');
          return null;
        }
      }

      // Function to transition the game state to "playing" after dealing animation completes
      async function updateGameStateToPlaying(gameSessionId) {
        console.log(`Updating game state to 'playing' for session: ${gameSessionId}`);
        try {
          const response = await fetch(`/games/gamesSession/${gameSessionId}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ state: 'playing' }) // Update game state to 'playing'
          });
          if (!response.ok) {
            console.error('Failed to update game state to playing.');
          } else {
            console.log('Game state successfully updated to playing.');
          }
        } catch (error) {
          console.error('Error updating game state:', error);
        }
      }

      // Initialize canvas context when available
      function initializeCanvasContext() {
        const canvas = document.querySelector('canvas');
        if (canvas) {
          ctx = canvas.getContext('2d');
          console.log("Canvas context initialized.");
        } else {
          console.error("Canvas not found.");
        }
      }

      // Handle the dealing phase (start animations, dealing dominoes, etc.)
      async function handleDealingPhase(updatedState) {
        const gameSessionId = updatedState.gameSessionId;
        const cardTableGameDiv = document.querySelector('.cardTableGameDiv');
        const gameSettingsData = extractGameSettingsData(cardTableGameDiv);

        if (gameSettingsData && ctx) {
          console.log("Starting dealing animation for players...");
          const playerPositions = [
            { x: 50, y: 350 },  // Player 1 position
            { x: 250, y: 350 }, // Player 2 position
            { x: 450, y: 350 }, // Player 3 position
            { x: 650, y: 350 }  // Player 4 position
          ];

          startDealingAnimation(ctx, playerPositions, gameSessionId);
        } else if (!ctx) {
          console.error("Canvas context is not initialized. Ensure the canvas is available.");
        } else {
          console.error("Error: Game settings or canvas context not available.");
        }
      }

      // Start dealing animation for a single domino
      function startDealingAnimation(ctx, playerPositions, gameSessionId) {
        console.log("Starting dealing animation...");
        dealingAnimationActive = true;
        let dealCount = 0;
        const maxDeals = 10; // Assuming each player gets 10 dominoes
        const dealInterval = setInterval(() => {
          if (dealCount >= maxDeals) {
            console.log("Dealing animation completed.");
            clearInterval(dealInterval);
            dealingAnimationActive = false;

            // After dealing, update the game state to 'playing'
            updateGameStateToPlaying(gameSessionId);
            return;
          }

          // For each deal, animate a domino flying to each player position
          playerPositions.forEach((position, index) => {
            console.log(`Dealing domino to player ${index + 1} at position:`, position);
            renderDealingAnimation(ctx, position.x, position.y, index);
          });

          dealCount++;
        }, 300); // Deal one domino every 300ms for 3 seconds
      }

      // Render dealing animation for a single domino
      function renderDealingAnimation(ctx, x, y, playerIndex) {
        console.log(`Rendering dealing animation for player ${playerIndex + 1} at (${x}, ${y})`);
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas

        // Simple dealing animation (can be improved with actual domino images)
        ctx.fillStyle = playerIndex % 2 === 0 ? 'blue' : 'green';
        ctx.fillRect(x, y, 40, 20); // Draw a "domino" as a rectangle

        // Optionally, add player labels
        ctx.font = "12px Arial";
        ctx.fillStyle = "white";
        ctx.fillText(`Player ${playerIndex + 1}`, x + 10, y + 15);
      }

      // Main setup function to load everything and render
      async function setupGameBoard(ctx, gameSettingsData, gameSessionId) {
        console.log("Setting up game board...");
        const spriteIds = gameSettingsData.spriteIds;
        if (!spriteIds || spriteIds.length === 0) {
          console.error("No spriteIds found in gameSettingsData.");
          return;
        }

        console.log("Fetching sprites and game elements...");
        await fetchSprites(spriteIds);   // Fetch sprites using _id
        await preloadImages();           // Preload and cache sprite images
        gameElements = await fetchGameElements(); // Fetch game elements and cache them

        if (gameElements.length) {
          console.log("Game elements and sprites loaded, initializing animation...");
          const playerPositions = [
            { x: 50, y: 350 }, // Player 1
            { x: 250, y: 350 }, // Player 2
            { x: 450, y: 350 }, // Player 3
            { x: 650, y: 350 }  // Player 4
          ];
          startDealingAnimation(ctx, playerPositions, gameSessionId); // Start dealing animation
        } else {
          console.error("No game elements found.");
        }
      }

      // MutationObserver to detect when EJS-rendered DOM is added
      const observer = new MutationObserver(async (mutations) => {
        mutations.forEach(mutation => {
          mutation.addedNodes.forEach(async (node) => {
            if (node.querySelector && node.querySelector('.cardTableGameDiv')) {
              console.log("Card table detected in DOM.");
              initializeCanvasContext(); // Initialize canvas context after it becomes available

              const gameSessionId = node.getAttribute('data-game-session-id');
              const cardTableGameDiv = document.querySelector('.cardTableGameDiv');
              const gameSettingsData = extractGameSettingsData(cardTableGameDiv);

              if (gameSettingsData && ctx) {
                await setupGameBoard(ctx, gameSettingsData, gameSessionId);
              }
            }
          });
        });
      });

      // Start observing the DOM for changes
      observer.observe(document.body, { childList: true, subtree: true });

      console.log("Game logic initialized.");
    });
</script>
