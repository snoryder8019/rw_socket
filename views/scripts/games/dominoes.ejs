<script>
document.addEventListener("DOMContentLoaded", function () {
    let spriteImagesCache = {}; // Cache for sprite images
    let spritesMap = {}; // To store sprites by _id
    let gameElements = []; // Store game elements
    let animationStates = []; // Store animation state for each domino independently
    let gameState = {};
    let dealingAnimationActive = false;

    // Extract gameSettingsData from the cardTableGameDiv's data attribute
    function extractGameSettingsData(cardTableGameDiv) {
        const gameSettings = cardTableGameDiv.getAttribute('data-game-settings');
        if (gameSettings) {
            return JSON.parse(gameSettings);
        } else {
            console.error('No gameSettingsData found on the cardTableGameDiv');
            return null;
        }
    }

    // 1. Fetch sprite images using spriteIds
    async function fetchSprites(spriteIds) {
        try {
            const response = await fetch('/games/gameSprites/allData'); // Fetch sprites from API
            const sprites = await response.json();

            // Map sprites by their _id
            sprites.forEach(sprite => {
                if (spriteIds.includes(sprite._id) && sprite.imageSrc) { // Check for _id
                    spritesMap[sprite._id] = sprite; // Store sprites by their _id
                }
            });
        } catch (error) {
            console.error('Error fetching sprites:', error);
        }
    }

    // 2. Preload and cache sprite images
    async function preloadImages() {
        const promises = Object.values(spritesMap).map(sprite => {
            return new Promise((resolve, reject) => {
                const img = new Image();
                img.src = sprite.imageSrc; // Use imageSrc from sprite object
                
                img.onload = () => {
                    spriteImagesCache[sprite._id] = img; // Cache image by _id
                    resolve();
                };
                
                img.onerror = () => {
                    console.error(`Failed to load image for spriteId: ${sprite._id}`);
                    reject();
                };
            });
        });

        await Promise.all(promises); // Wait for all images to load
    }

    // Add a 3-second dealing animation
    function startDealingAnimation(ctx, playerPositions) {
        dealingAnimationActive = true;
        let dealCount = 0;
        const maxDeals = 10; // Assuming each player gets 10 dominoes
        const dealInterval = setInterval(() => {
            if (dealCount >= maxDeals) {
                clearInterval(dealInterval);
                dealingAnimationActive = false;
                return;
            }
            
            // For each deal, animate a domino flying to each player position
            playerPositions.forEach((position, index) => {
                renderDealingAnimation(ctx, position.x, position.y, index);
            });

            dealCount++;
        }, 300); // Deal one domino every 300ms for 3 seconds
    }

    // Render dealing animation for a single domino
    function renderDealingAnimation(ctx, x, y, playerIndex) {
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas

        // Simple dealing animation (can be improved with actual domino images)
        ctx.fillStyle = playerIndex % 2 === 0 ? 'blue' : 'green';
        ctx.fillRect(x, y, 40, 20); // Draw a "domino" as a rectangle

        // Optionally, add player labels
        ctx.font = "12px Arial";
        ctx.fillStyle = "white";
        ctx.fillText(`Player ${playerIndex + 1}`, x + 10, y + 15);
    }

    // Main setup function to load everything and render
    async function setupGameBoard(ctx, gameSettingsData) {
        const spriteIds = gameSettingsData.spriteIds;
        if (!spriteIds || spriteIds.length === 0) {
            console.error("No spriteIds found in gameSettingsData.");
            return;
        }

        await fetchSprites(spriteIds);   // Fetch sprites using _id
        await preloadImages();           // Preload and cache sprite images
        gameElements = await fetchGameElements(); // Fetch game elements

        if (gameElements.length) {
            initializeAnimationState(); // Initialize animation state for each element
            const playerPositions = [
                { x: 50, y: 350 }, // Player 1
                { x: 250, y: 350 }, // Player 2
                { x: 450, y: 350 }, // Player 3
                { x: 650, y: 350 }  // Player 4
            ];
            startDealingAnimation(ctx, playerPositions); // Start dealing animation

            // Wait until the dealing animation completes, then start the game
            setTimeout(() => {
                requestAnimationFrame(() => renderGameElements(ctx));
            }, 3000); // Wait for 3 seconds before starting game elements animation
        } else {
            console.error("No game elements found.");
        }
    }

    // MutationObserver to trigger setup when the cardTableGameDiv is added to the DOM
    const observer = new MutationObserver((mutations) => {
        mutations.forEach((mutation) => {
            mutation.addedNodes.forEach((node) => {
                if (node.classList && node.classList.contains('cardTableGameDiv')) {
                    const gameSettingsData = extractGameSettingsData(node);
                    if (!gameSettingsData) return;

                    const canvas = document.createElement('canvas');
                    const divWidth = node.clientWidth;
                    canvas.width = divWidth;
                    canvas.height = 400;
                    node.appendChild(canvas);
                    const ctx = canvas.getContext('2d');

                    // Set up the game board and run dealing animation
                    setupGameBoard(ctx, gameSettingsData);
                }
            });
        });
    });

    // Observe for changes in the DOM
    observer.observe(document.body, { childList: true, subtree: true });
});


</script>