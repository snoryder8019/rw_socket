<!DOCTYPE html>
<html>
<head>
  <title>Video Stream</title>
  <style>
  
  </style>
</head>
<body>
<div class="index-container">
  <div class="container-scrollbox-x">
    <div class="index-card active">
      <div class="client_window">
        <button class="videoControls start" onclick="startCamera()">Start Camera</button>
        <button class="videoControls stop" onclick="stopCamera()">Stop Camera</button>
        <button class="go-back" onclick="showPreviousCard()">Go Back</button>
      </div>
    </div>
    <div class="index-card">
      <div class="p2pRoomsList">
        <h3>Join a Parlor Room:</h3>
        <% if (typeof rooms == 'object' && rooms) { %>
          <% rooms.forEach(room => { %>
            <div>
              <button class="videoControls" button-data="<%= room._id %>" onclick="joinRoom('<%= room._id %>')"><h4> <%= room.name || room._id %></h4></button>
              <% if (user.isAdmin) { %>
                <button class="videoControls stop" button-data="<%= room._id %>" onclick="deleteRoom('<%= room._id %>')">Delete</button>
              <% } %>
            </div>
          <% }) %>
        <% } %>
        <button class="go-back" onclick="showPreviousCard()">Go Back</button>
      </div>
    </div>
    <div class="index-card">
      <div class="peers"></div>
      <div class="P2Pcontrols"></div>
      <button class="go-back" onclick="showPreviousCard()">Go Back</button>
    </div>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
  const socket = io('/videoStream');
  let localStream;
  let peers = {};

  async function getMedia() {
    try {
      localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: false});
      const videoElement = document.getElementById('myVideo');
      videoElement.srcObject = localStream;
    } catch (err) {
      console.error(err);
    }
  }

  function startCamera() {
    getMedia();
    showNextCard();
  }

  function stopCamera() {
    const tracks = localStream.getTracks();
    tracks.forEach(track => track.stop());
    localStream = null;
    document.getElementById('myVideo').srcObject = null;
    showNextCard();
  }

  function showNextCard() {
    const currentCard = document.querySelector('.index-card.active');
    const nextCard = currentCard.nextElementSibling;
    if (nextCard && nextCard.classList.contains('index-card')) {
      currentCard.classList.remove('active');
      nextCard.classList.add('active');
    }
  }

  function showPreviousCard() {
    const currentCard = document.querySelector('.index-card.active');
    const previousCard = currentCard.previousElementSibling;
    if (previousCard && previousCard.classList.contains('index-card')) {
      currentCard.classList.remove('active');
      previousCard.classList.add('active');
    }
  }

  async function createRoom() {
    const roomName = document.getElementById('roomName').value;
    try {
      const response = await fetch('/videoStream/createRoom', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ roomName })
      });
      const data = await response.json();
      console.log(`Room created with ID: ${data.roomId}`);
    } catch (error) {
      console.error('Failed to create room', error);
    }
  }

  function joinRoom(roomId) {
    socket.emit('joinRoom', roomId);
    showNextCard();
  }

  async function deleteRoom(roomId) {
    try {
      const response = await fetch('/videoStream/deleteRoom', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ roomId })
      });
      const data = await response.json();
      if (data.success) {
        console.log(`Room deleted: ${roomId}`);
        document.querySelector(`button[onclick="joinRoom('${roomId}')"]`).parentElement.remove();
      }
    } catch (error) {
      console.error('Failed to delete room', error);
    }
  }

  function setupPeerConnection(peerId) {
    const peerConnection = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });

    peers[peerId] = peerConnection;

    localStream.getTracks().forEach(track => peerConnection.addTrack(track, localStream));

    peerConnection.onicecandidate = event => {
      if (event.candidate) {
        socket.emit('p2pCandidate', {
          peerId: peerId,
          candidate: event.candidate
        });
      }
    };

    peerConnection.ontrack = event => {
      const videoElement = document.createElement('video');
      videoElement.srcObject = event.streams[0];
      videoElement.autoplay = true;
      videoElement.className = "peer";
      document.querySelector('.peers').appendChild(videoElement);
    };

    return peerConnection;
  }

  function startCall(peerId) {
    const peerConnection = setupPeerConnection(peerId);

    peerConnection.createOffer()
      .then(offer => peerConnection.setLocalDescription(offer))
      .then(() => {
        socket.emit('p2pInit', {
          peerId: peerId,
          offer: peerConnection.localDescription
        });
      });
  }

  socket.on('p2pOffer', async (data) => {
    const peerConnection = setupPeerConnection(data.from);

    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    socket.emit('p2pAnswer', {
      peerId: data.from,
      answer: peerConnection.localDescription
    });
  });

  socket.on('p2pAnswer', async (data) => {
    const peerConnection = peers[data.from];
    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
  });

  socket.on('p2pCandidate', async (data) => {
    const peerConnection = peers[data.from];
    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
  });

  socket.on('updateRooms', (rooms) => {
    const roomsList = document.querySelector('.p2pRoomsList');
    roomsList.innerHTML = '';
    rooms.forEach(room => {
      const roomElement = document.createElement('div');
      roomElement.classList.add('room');
      roomElement.innerHTML = `
        <span>${room.name || room.id}</span>
        <span>Guests: ${room.guests}</span>
        <button onclick="joinRoom('${room.id}')">Join</button>
        <button onclick="deleteRoom('${room.id}')">Delete</button>
      `;
      roomsList.appendChild(roomElement);
    });
  });

  socket.on('roomState', (room) => {
    if (room.offer && !peers[room._id]) {
      startCall(room._id);
    }
    if (room.answer) {
      const peerConnection = peers[room._id];
      peerConnection.setRemoteDescription(new RTCSessionDescription(room.answer));
    }
    room.candidates.forEach(candidate => {
      const peerConnection = peers[room._id];
      peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
    });
  });

  socket.on('userJoined', (data) => {
    startCall(data.userId);
  });

  // Handle marquee updates
  socket.on('marquee', (message) => {
    const marqueeText = document.getElementById('marquee-text');
    marqueeText.innerHTML += ` ${message} `;
  });
</script>
</body>
</html>
